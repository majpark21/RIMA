#' Calculate Neighbourhood-Neighbourhood Significance
#'
#' Runs a pipeline to assign p-values to neighbourhood-neighbourhood edges
#' by comparing true neighbourhood-neighbourhood similarities against a null
#' distribution generated by cell identity scrambling and computing similarities
#' between true and scrambled neighbourhoods.
#' Optionally tests in both directions and combines p-values using Simes' method.
#'
#' @param milos A list of 2 Milo objects. The \code{direction} determines which
#'   object is kept intact  and which is scrambled to generate the null.
#' @param dt_sims A data.table with 3 columns as returned by \code{calculate_similarities()}.
#'   The first 2 columns indicate neighbourhood pairs, the third column (named \"sim\")
#'   contains similarity values between intact neighbourhoods.
#' @param n_scrambles Integer. Number of rounds of cell resampling to generate the null distribution.
#' @param col_scramble_label Character string specifying a column in the scrambled Milo's \code{colData}.
#'   Label frequencies are estimated from this column to weight the sampling probability of each cell
#'   during scrambling. Cells with common labels are less likely to be sampled. Use \"false\" for unweighted sampling.
#'   Default is \"false\".
#' @param assay Character string specifying the assay to use for calculating neighbourhood expression.
#'   Default is \"logcounts\".
#' @param sim_method Character string specifying the similarity metric.
#'   Must be one of \"pearson\", \"kendall\", or \"spearman\". Default is \"spearman\".
#' @param adjust Character string specifying the method for p-value adjustment.
#'   Must be a valid method in \code{p.adjust()}. If \code{NULL}, no adjustment is applied.
#'   Default is \"holm\".
#' @param alpha_adjust Numeric. Significance level for calling edges significant.
#'   Float between 0 and 1. Default is 0.05.
#' @param direction Character string specifying the direction of testing.
#'   Must be one of:
#'   \\describe{
#'     \\item{\"lr\"}{Left-right: 1st Milo intact, 2nd scrambled.}
#'     \\item{\"rl\"}{Right-left: 2nd Milo intact, 1st scrambled.}
#'     \\item{\"b\"}{Bidirectional (default): tests both directions and combines p-values using Simes' method.}
#'   }
#'
#' @details
#' The function performs the following steps:
#' 1. Scrambles neighbourhoods in one (or both) Milo object(s).
#' 2. Generates a null distribution by calculateing similarities between original neighbourhoods and scrambled neighbourhoods.
#' 3. Estimates empirical p-values by comparing true similarities to the null distribution.
#' 4. Applies multiple testing correction.
#' 5. If bidirectional, combines p-values from both directions using Simes' method.
#'
#' @returns A data.table based on \\code{dt_sims}, with additional columns:
#'   \\item{pval}{Empirical p-value for each neighbourhood pair.}
#'   \\item{pval_adjusted}{Adjusted p-value after multiple testing correction.}
#'   \\item{is_significant}{Logical indicating whether the pair is significant at \\code{alpha_adjust}.}
#'   (For bidirectional testing, also includes pval_lr, pval_rl, pval_combined, etc.)
#'
#' @export
#'
#' @examples
#' # Not run: dt_sims_sig <- calculate_nhoodnhood_significance(milos, dt_sims, n_scrambles = 10)
calculate_nhoodnhood_significance <- function(milos,
                                              dt_sims,
                                              n_scrambles,
                                              col_scramble_label = "false",
                                              assay = "logcounts",
                                              sim_method = "spearman",
                                              adjust = "holm",
                                              alpha_adjust = 0.05,
                                              direction = c('b', 'lr', 'rl')) {
  direction <- match.arg(direction)
  # Arguments for .calculate_nhoodnhood_significance_oneway() common to all calls, no matter the direction
  ls_args_common <- list(
    col_scramble_label = col_scramble_label,
    n_scrambles = n_scrambles,
    assay = assay,
    sim_method =  sim_method,
    adjust = adjust,
    alpha_adjust = alpha_adjust
  )
  name_milo1 <- colnames(dt_sims)[1]
  name_milo2 <- colnames(dt_sims)[2]

  # Left -> Right: 1st Milo intact, 2nd Milo scrambled ============================================
  if (direction == 'lr') {
    cols_sim <- c(name_milo1, name_milo2, "sim")
    ls_args <- list(
      milos = list(milos[[1]], milos[[2]]),
      name_intact = name_milo1,
      name_scramble = name_milo2,
      dt_sims_true = dt_sims[, ..cols_sim]
    )
    ls_args <- append(ls_args, ls_args_common)
    dt_sims_withSignif <- do.call(.calculate_nhoodnhood_significance_oneway, ls_args)
    dt_sims_withSignif[, is_significant := pval_adjusted <= alpha_adjust]
  }
  # Right -> Left: 2nd Milo intact, 1st Milo scrambled ============================================
  else if (direction == 'rl') {
    cols_sim <- c(name_milo2, name_milo1, "sim")
    ls_args <- list(
      milos = list(milos[[2]], milos[[1]]),
      name_intact = name_milo2,
      name_scramble = name_milo1,
      dt_sims_true = dt_sims[, ..cols_sim]
    )
    ls_args <- append(ls_args, ls_args_common)
    dt_sims_withSignif <- do.call(.calculate_nhoodnhood_significance_oneway, ls_args)
    dt_sims_withSignif[, is_significant := pval_adjusted <= alpha_adjust]
  }
  # Both directions: does lr, then rl, and combine the pvalues from both ==========================
  else if (direction == 'b') {
    ls_pvals <- list()

    # left -> right
    cols_sim <- c(name_milo1, name_milo2, "sim")
    ls_args <- list(
      milos = list(milos[[1]], milos[[2]]),
      name_intact = name_milo1,
      name_scramble = name_milo2,
      dt_sims_true = dt_sims[, ..cols_sim]
    )
    ls_args <- append(ls_args, ls_args_common)
    ls_pvals[[1]] <- do.call(.calculate_nhoodnhood_significance_oneway, ls_args)

    # right -> left
    cols_sim <- c(name_milo2, name_milo1, "sim")
    ls_args <- list(
      milos = list(milos[[2]], milos[[1]]),
      name_intact = name_milo2,
      name_scramble = name_milo1,
      dt_sims_true = dt_sims[, ..cols_sim]
    )
    ls_args <- append(ls_args, ls_args_common)
    ls_pvals[[2]] <- do.call(.calculate_nhoodnhood_significance_oneway, ls_args)

    # Return p-values from both directions; combine with Simes method and adjust the combined Pvalues
    cat("Combining left-right and right-left pvalues...")
    dt_sims_withSignif <- merge(
      ls_pvals[[1]],
      ls_pvals[[2]],
      by = c(name_milo1, name_milo2),
      suffixes = c("_lr", "_rl")
    )
    dt_sims_withSignif[, pval_combined := .combine_2pvals_simes(pval_lr, pval_rl), by =
                         1:nrow(dt_sims_withSignif)]
    dt_sims_withSignif[, pval_adjusted_combined := p.adjust(pval_combined, method =
                                                              adjust)]
    dt_sims_withSignif[, is_significant := pval_adjusted_combined <= alpha_adjust]

    # Consistent column names and order with unidirectional
    dt_sims_withSignif[, sim := sim_lr]  # duplicated sim_lr and sim_rl if sim_method is symmetrical
    setcolorder(dt_sims_withSignif, c(name_milo1, name_milo2, "sim"))
  }

  return(dt_sims_withSignif)
}
